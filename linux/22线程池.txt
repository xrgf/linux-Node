回顾：
	1. 线程   并发 
		进程 和 线程的区别
	2. 临界数据     
		线程同步：
			原子锁  自旋锁  信号量（旗语）
			读写锁  条件变量  互斥    
			信号  事件 。。
	3. 死锁
		如果同时满足如下四种情况  就会造成死锁   程序就卡死了  解不开
			1. 请求又保持      加锁 
			2. 不可撤销        
			3. 不可摧毁 
			4. 循环请求
	4. 粒度
		粒度大：     锁很少       锁消耗资源少       程序使用效率低
		粒度小：     锁很多       锁消耗资源多       程序使用效率高

池化：
	N个任务       任务池        多个任务  放到池中       储水池  
	N个线程       线程池        包工头     美团 
		100个线程     3个线程         50个线程  
				一般情况  养着   固定个数的线程    （某线程处理完某个人物后不删除 处理下一个人物） 节约线程创建和删除的开销

线程池：
	3个线程：
		任务线程：把任务放入任务池中      
			1. 任务类
			2. 创建节点
			3. 节点入链表 入队
		管理线程：
			从任务池中取出任务交给线程池中某个线程处理
		监督线程：监督线程池
			线程池中线程过少    添加一点
			线程池中空闲线程过多  减少一点
	2个池：
		任务池：数据结构  （链表，队列）
		线程池：数据结构  （链表，队列）


管理线程做什么事情：
	1. 从任务池中获取一个未分配的任务
		如果没有未分配任务  阻塞  等待任务线程添加任务到任务池
	2. 如果有未分配任务，从线程池中获取一个空闲线程  分配给它
		如果没有空闲线程    阻塞  等待监督线程工作（添加线程）
	3. 更改线程属性（状态改变，加锁）
	4. 修改任务池（把任务从任务池中删除）
	5. 启动线程
	6. 回到第一步

每个项目有个总体的解释：
	解释整个项目的功能
	每个文件的功能

每个文件中：
	解释这个文件的功能
	提供哪些接口（函数）

每个函数：
	注释 ：
		函数功能解释
		参数解释
		返回值解释
		时间
		版本
		作者

学习：
	easyX的  帮助文档
	F1   微软的帮助文档
	qtCreator的帮助文档

	具体：公司会有要求

struct threadPoll{
	int		number;
	int		queue_max_num;

	struct 	job*		head;
	struct  job*		tail;

	pthread_t*	pthreads;//存放所有线程的id

	pthread_mutex_t		mutex;//互斥量
	//条件变量
	pthread_cond_t 		queue_empty;
	pthread_cond_t 		queue_not_empty;
	pthread_cond_t 		queue_not_full;

	int 	queue_job_num;	//当前任务数
	int		queue_close;	//任务池是否关闭
	int  	poll_close;		//线程池是否关闭
};



assert:断言   
	参数 是  我们程序员  断言的。
	